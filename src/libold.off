use pyo3::prelude::*;

use std::{io, sync::Arc};

use actix_cors::Cors;
use actix_web::{
    get, middleware, route,
    web::{self, Data},
    App, HttpResponse, HttpServer, Responder,
};
use actix_web_lab::respond::Html;
use juniper::http::{graphiql::graphiql_source, GraphQLRequest};
// use serde::{Serialize, Deserialize};

// #[derive(Serialize, Deserialize, Debug)]
mod schema;

use crate::schema::{create_schema, Schema};

// struct Query {
//     value: String
// }

// impl Query {
//     fn get(&self) -> String {
//         self.value
//     }
//     fn set(input: String) {
//         self.value = input;
//     }
// }



//    let query = Query {
//         value: ""
//     };
/// GraphiQL playground UI
#[get("/graphiql")]
async fn graphql_playground() -> impl Responder {
    Html(graphiql_source("/graphql", None))
}

/// GraphQL endpoint
#[route("/graphql", method = "GET", method = "POST")]
async fn graphql(st: web::Data<Schema>, data: web::Json<GraphQLRequest>) -> impl Responder {
    let user = data.execute(&st, &()).await;
    // match serde_json::to_string(&user.serialize()) {
    //     Ok(result) => query = result,
    //     _ => {
    //         //
    //     }
    // }
    HttpResponse::Ok().json(user)
}

#[actix_web::main]
async fn main() -> io::Result<()> {
    env_logger::init_from_env(env_logger::Env::new().default_filter_or("info"));

    // Create Juniper schema
    let schema = Arc::new(create_schema());

    log::info!("starting HTTP server on port 8080");
    log::info!("GraphiQL playground: http://localhost:8080/graphiql");
    #[pyfunction]
    async fn init(a: usize, b: usize) -> PyResult<String> {
        HttpServer::new(move || {
            App::new()
                .app_data(Data::from(schema.clone()))
                .service(graphql)
                .service(graphql_playground)
                // the graphiql UI requires CORS to be enabled
                .wrap(Cors::permissive())
                .wrap(middleware::Logger::default())
        })
        .workers(2)
        .bind(("127.0.0.1", 8080))?
        .run()
        .await
        Ok((a * b).to_string())
    }

    /// A Python module implemented in Rust.
    #[pymodule]
    fn gqltest(_py: Python, m: &PyModule) -> PyResult<()> {
        m.add_function(wrap_pyfunction!(init, m)?)?;
        // m.add_function(wrap_pyfunction!(testql, m)?)?;
        Ok(())
    }


    // Start HTTP server

}


    // #[pyfunction]
    // fn init(a: usize) -> PyResult<String> {
    //     main();
    //     Ok((a * 2).to_string())
    // }

    // #[pymodule]
    // fn gqltest(_py: Python, m: &PyModule) -> PyResult<()> {
    //     m.add_function(wrap_pyfunction!(init, m)?)?;
    //     Ok(())
    // }